# 11장 - 코루틴 스코프 함수

## 코루틴 사용시 안티패턴

### GlobalScope에 async를 사용하지 말자.

- `GlobalScope` 는 그저 `EmptyCoroutineContext`를 가진 스코프임.
- `GlobalScope` 에서 async를 호출하면 부모 코루틴과 아무런 관계가 없음.
    - `EmptyCoroutineContext` 이기 때문.
- 취소 될 수 없고, 부모로부터 스코프를 상속 받지도 않음.
    - 이는 메모리 누수가 발생할 수 있으며 쓸데없이 CPU를 낭비함.

### 스코프를 인자로 넘기거나 확장함수로 설계하지 말자

- 스코프가 함수에서 함수로 전달되기 때문에 예상하지 못한 사이드 이펙트가 발생할 수 있음.
    - ex) Job으로 설계한 경우 async에서 예외가 발생시 모든 스코프가 닫히게됨.
- 스코프에서 접근하는 함수가 `cancel` 메서드를 사용해 스코프를 조작할 수도 있음.

## coroutineScope

```kotlin
public suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R
```

- 스코프를 시작하는 중단함수이며, 인자로 들어온 함수가 생성한 값을 반환함.
- `coroutineScope` 함수는 새로운 코루틴을 생성하지만 새로운 코루틴이 끝날 때까지 `coroutineScope` 를 호출한 코루틴을 중단함.
    - 즉, 호출한 코루틴이 작업을 동시에 시작하지는 않음.
- 생성된 스코프는 바깥의 스코프에서 코루틴 컨텍스트를 상속받지만, 컨텍스트의 `Job`을 오버라이딩함.
- 따라서 생성된 스코프는 부모가 해야 할 책임을 이어받음.
    - 부모로부터 컨텍스트를 상속받음.
    - 자신의 작업을 끝내기 전까지 모든 자식을 기다림.
    - 부모가 취소되면 자식들 모두를 취소함.
- 코루틴 빌더와 달리 `coroutineScope` 나 스코프에 속한 자식에서 예외가 발생하면 다른 모든 자식이 취소되고 예외가 다시 던져짐.
- 중단 함수에서 병렬로 작업을 수행할 경우 `coroutineScope` 를 사용하는 것이 좋음.

## 코루틴 스코프 함수

- 스코프를 만드는 함수는 다양하게 있고, 이는 `coroutineScope` 와 비슷하게 작동함.
    - `supervisorScope`
    - `withContext`
    - `withTimeout`

## 코루틴 스코프 함수 연결하기

- 서로 다른 코루틴 스코프 함수의 두 가지 기능이 모두 필요하다면 코루틴 스코프 함수에서 다른 기능을 가지는 코루틴 스코프 함수를 호출해야 함.

```kotlin
suspend fun calculateAnswerOrNull(): User? =
    withContext(Dispatchers.Default) {
        withTimeoutOrNull(1000) {
            calculateAnswer()
        }
    }
```

## 추가적인 연산

- 작업을 수행하는 도중 추가적인 연산을 수행하는 경우도 있음.
    - ex) 유저의 프로필을 보여준 후, 분석을 위한 목적으로 요청을 보낼 때
- 위 같은 경우 동일한 스코프에서 launch를 호출하는 방법이 자주 사용됨.
    - 핵심 동작에 영향을 주지 않는 추가적인 연산이 있을 경우 또 다른 스코프에서 시작하는 편이 나음.
    - 코루틴 스코프를 생성자 주입하자!
        - 함수는 X
- 주입된 스코프에서 추가적인 연산을 시작하는 건 자주 사용되는 방법임.
- 스코프를 전달하면 전달된 클래스를 통해 독립적인 작업을 실행한다는 것을 명확하게 알 수 있음.
- 따라서 중단 함수는 주입된 스코프에서 시작한 연산이 끝날 때까지 기다리지 않음.
    
    

## 궁금한 것

1. p.129 `coroutineScope` 는 생성시 해당 블록에 있는 로직을 수행?
    1. “`coroutineScope` 함수는 새로운 코루틴을 생성하지만 새로운 코루틴이 끝날 때까지 `coroutineScope` 를 호출한 코루틴을 중단함”
2. p.131 `coroutineScope` 에서 예외가 다시 던져지면 부모 코루틴으로 던져지는?
3. 133p. 코드에서 첫 번짼 동기식, 두 번짼 비동기식?
4. 요건 그냥 갑자기 궁금해짐. 2개의 api를 호출 시 병렬로 처리할 때, launch도 되져?
5. 코루틴 스코프 함수를 사용하는 경우의 가장 Best한 방법이 뭘까요?.? 해당 스코프는 일시중단 때문에? 이는 동기식으로 작동하는? 코루틴 빌더랑 코루틴 스코프랑 큰 차이를 못느끼겠는데, 연주님 의견이 궁금해요!
6. 143p. 실행 흐름이 그러면 어떻게 되는지? 주입된 스코프에서 시작한 연산이 끝날 때까지 기다리지않음?
    1. 코루틴 스코프가 끝나면 종료?
    2. 실행 흐름 같이 보시죠!

## 답변
1. 맞음! coroutineScope는 일시중단 함수임.
2. 맞음! 코루틴 스코프를 호출한 상위 코루틴 or 일시 중단 함수는 코루틴 스코프와 자식-부모 관계가아니므로, 예외를 리스로잉 하는 것.
3. 맞음!
4. 맞음! 결과값일 땐 aysnc 사용
5. 일시 중단 함수 안에선 코루틴 빌더들을 호출하지 못하므로, 이를 가능하게 해주는 것이 코루틴 스코프임.
6. 구조화된 동시성을 만족하려면 코루틴 스코프 안에서 코루틴 빌더 or 코루틴 스코프를 만들어야함.

```kotlin
suspend fun main(): Unit = coroutineScope { // 1
    try {
        coroutineScope { // 2
            launch { // 3
				throw Exception("gdgdd")
            }
        }
    } catch (e: Exception) {
		println(e.message)
    }
}
```
실행결과 : gdgdd
