![image](https://github.com/jiwon2724/TIL/assets/70135188/9097d0da-e86b-4e36-ae67-d82f12c0f0cc)


### O(1)의 시간복잡도를 가진 알고리즘

- 입력값이 증가 하더라도 시간이 늘어나지 않는다. ex) 배열의 index로 접근해 해당 데이터 반환

### O(log n)의 시간복잡도를 가진 알고리즘

- 한번 연산이 진행될 때 마다 처리해야하는 데이터의 수가 줄어듬.
    - ex) 이진 탐색

### O(n log n)의 시간복잡도를 가진 알고리즘

- n번만큼의 반복문이 실행되지만, 각 반복에서는 log n의 연산이 일어나는 경우임.
    - 합병, 힙, 정렬 등

### O(n)의 시간 복잡도를 가진 알고리즘

- 입력값이 증가함에 따라 시간 또한 같은 비율로 증가하는 것을 의미한다.
    - ex) 입력값이 1일 때는 1초, 100일 땐 100초

```kotlin
fun bigOnAlgorithm(n: Int) {
    for(i in 0..n-1) {
        // 만약 n이 2n이라고 해도 O(n)이라고 표기한다.
        // 입력값이 커질수록 계수(n앞에 있는 수)가 점점 퇴색되기 때문에 O(n)으로 표기.
    }
}
```

### **O(n^2)의 시간 복잡도를 가진 알고리즘**

- 입력값이 증가함에 따라 시간이 n의 제곱수 비율로 증가.
    - ex) 입력값이 1일경우 1초가 걸리는 알고리즘에 5를 입력했을 때 걸리는 시간은 25초임.
- 2중 for문, 3중 for문 그 이상을 다 O(n^2)이라고 부름.

### O(2^n)의 시간 복잡도를 가진 알고리즘

빅오 표기법 중 가장 느린 시간복잡도를 가진다.

그만 알아보자.

# 정렬 알고리즘 비교

![image](https://github.com/jiwon2724/TIL/assets/70135188/072d704b-6b56-4251-9e8e-e53f2bb532f1)


# 자료구조 비교

![image](https://github.com/jiwon2724/TIL/assets/70135188/f84445a0-9069-464a-a266-1738ed302146)
