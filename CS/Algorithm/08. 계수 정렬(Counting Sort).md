# 계수 정렬

- 양수 정렬 알고리즘의 하나임.
- 크기를 기준으로 갯수를 셈(Count).
    - 범위 조건이 있는 경우에 한해서 굉장히 빠른 알고리즘임. O(n)
        - ex) 5이하 자연수 데이터들을 오름차순 정렬
- 크기를 기준으로 갯수만 세주면 되기 때문에 위치를 바꿀 필요가 없음.

### 알고리즘

- 배열을 탐색하면서 조건을 충족한 경우 세면됨.
- 세어진 원소 배열을 출력함.

### 예시

정렬되지 않은 배열로 가정하고, 오름차순으로 정렬 프로세스로 가정. 

→ `[1, 3, 2, 4, 3, 2, 5, 3, 1, 2]`

- 원소의 최댓값에 따라서 count역할을 하는 배열의 크기그 정해짐.
- 원소들이 들어있는 배열의 인덱스를 하나씩 확인하면서 count 배열에 누적시킴.

### 소스코드 - Kotlin

```kotlin
fun main() {
    val count = intArrayOf(0, 0, 0, 0, 0)
    val array = intArrayOf(1, 3, 2, 4, 3, 2, 5, 3, 1, 2)

    array.forEach { count[it-1]++ }

    for(i in count.indices) {
        if(count[i] != 0) {
            repeat(count[i]) {
                print(i+1)
            }
        }
    }
}
```

### 범위 및 함수 사용시 유의사항

- `indices` : `IntRange`타입을 반환하며,수신객체의 전체 범위 반환. 위 예제 에선 0..6
- `until` : 범위의 마지막 요소를 포함하지 않음.
    - `0..5` => 0, 1, 2, 3, 4, 5
    - `0 until 5` => 0, 1, 2, 3, 4
- `numbers.size` , `numbers.lastIndex` 을 주의해서 사용.

### 장점

- 시간 복잡도가 일정함.
- 구현이 간단함

### 단점

- 숫자의 범위가 넓어질수록 추가 메모리 요구량이 증가함.

### 시간 복잡도

- 최선, 최악, 평균 : `O(n+k)`
    - k가 n보다 크지 않다면 O(n)에 가까운 시간 복잡도를 가짐.
        - k는 배열 원소의 최댓값.

### 공간 복잡도

- `O(k)`
    - 최댓값을 기준으로 배열을 하나 만들어야함.
