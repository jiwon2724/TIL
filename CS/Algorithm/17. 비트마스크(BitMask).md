# 비트 마스크

- 비트마스크(BitMask)는 이진수를 사용하는 컴퓨터의 연산 방식을 사용하여, 정수의 이진수 표현을 쓰는 기법임.
    - 비트 연산을 사용하여 특정 비트들을 “마스킹”함
        - 마스킹 : 선택, 변경, 검사 등
- 이진수는 0 or 1을 이용하므로 하나의 비트가 표현할 수 있는 경우는 두 가지임.
    - 1이면 ON, 0이면 OFF
- 수행 시간이 빠르고 코드가 짧으며, 메모리 사용량이 적음.

### 비트 연산

1. **AND 연산 (&)**: 두 비트 모두 1일 경우에만 1을 반환.
2. **OR 연산 (|)**: 두 비트 중 하나라도 1일 경우 1을 반환.
3. **XOR 연산 (^)**: 두 비트가 다를 경우에만 1을 반환.
4. **NOT 연산 (~)**: 비트를 반전시킵니다. 1은 0으로, 0은 1로 변환됨.
5. **왼쪽 시프트 (<<)**: 비트를 왼쪽으로 옮김.
6. **오른쪽 시프트 (>>)**: 비트를 오른쪽으로 옮김.

### 비트 마스킹

1. **값 확인**: 특정 위치의 비트가 1인지 0인지 확인할 수 있음. → AND
2. **값 설정**: 특정 위치의 비트를 1로 설정할 수 있음. → OR
3. **값 제거**: 특정 위치의 비트를 0으로 설정할 수 있음. → AND, NOT
4. **값 토글**: 특정 위치의 비트 값을 반전시킬 수 있음. → XOR

```kotlin
fun main() {
    // 초기 비트마스크를 모두 0으로 설정합니다.
    var bitmask = 0b0000 // 결과: 0000 (10진수로 0)

    // 값 설정 (3번째 비트를 1로 설정)
    // 1을 2칸 왼쪽으로 시프트하면 0010이 되고, 이를 OR 연산하면 3번째 비트만 1이 설정됩니다.
    bitmask = bitmask or (1 shl 2)
    println(Integer.toBinaryString(bitmask)) // 출력: 100

    // 값 확인 (3번째 비트 확인)
    // 3번째 비트가 1인지 확인하기 위해 AND 연산을 사용합니다.
    // 결과가 0이 아니면 3번째 비트는 1이라는 것을 의미합니다.
    val isSet = bitmask and (1 shl 2) != 0
    println(isSet) // 출력: true (3번째 비트는 1이므로 true)

    // 값 제거 (3번째 비트를 0으로 설정)
    // 3번째 비트만 0으로 만들고자 ~(1 shl 2)를 사용하여 3번째 비트만 0인 마스크를 생성합니다.
    // AND 연산을 통해 3번째 비트만 0으로 만듭니다.
    bitmask = bitmask and (1 shl 2).inv()
    println(Integer.toBinaryString(bitmask)) // 출력: 0 (모든 비트가 0이므로)

    // 값 토글 (3번째 비트 토글)
    // XOR 연산은 두 비트가 다르면 1을 반환하므로, 토글(반전) 효과를 얻을 수 있습니다.
    bitmask = bitmask xor (1 shl 2)
    println(Integer.toBinaryString(bitmask)) // 출력: 100 (3번째 비트가 다시 1로 설정됨)
}
```

### 비트 마스크로 각 요소를 인덱스처럼 표현

```kotlin
[1,2,3,4,5] → 11111
[2,3,4,5]   → 11110
[1,2,5]     → 10011
[2]         → 00010
```

- 비트 마스킹을 통해 제어가 가능.
